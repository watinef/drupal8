<?php
use Drupal\cogecotv_base\Community;
use \Drupal\Core\Url;
use Drupal\Component\Utility\Html;
use Drupal\Component\Utility\Unicode;
use Drupal\filter\Entity\FilterFormat;

use \Drupal\cogecotv_base\Form\PublishVideo;

/**
 * Implements hook_theme().
 */
function cogecotv_base_theme($existing, $type, $theme, $path) {
  $variables = array(
    'community_selection' => array(
      'variables' => array(
        'communities' => NULL,
      ),
      'template' => 'community_selection',
    ),
    'community_home_page' => array(
      'variables' => array(
        'community' => NULL,
      ),
      'template' => 'community_home_page',
    ),
    'header_links' => array(
      'variables' => array(
      ),
      'template' => 'header_links',
    ),
      'top_header' => array(
          'variables' => array(
              'quicklinks' => NULL,
          ),
          'template' => 'top_header',
      ),
      'navigation' => array(
          'variables' => array(
              'quicklinks' => NULL,
          ),
          'template' => 'navigation',
      ),
    'social_media' => array(
        'variables' => array(
          'social_media' => NULL,
        ),
        'template' => 'social_media',
    ),
    'error_404' => array(
        'template' => 'error_404',
      'variables' => array(
        'language' => NULL
      ),
    ),
      'weather' => array(
          'variables' => array(
          ),
          'template' => 'weather',
      ),

      'static_page' => array(
          'variables' => array(
              'page_name' => NULL,
          ),
          'template' => 'static_page',
          ),
  );
  return $variables;
}

/**
 * Add custom behavior to video edit form
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function cogecotv_base_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  if ($form_id == 'node_videos_edit_form' || $form_id == 'node_videos_form') {
    PublishVideo::formAlter($form, $form_state, $form_id);
  }
}


/**
 * Generates a collapsible text.
 *
 * Based on text_summary drupal core function
 */
function cogecotv_base_text_collapsible($text, $format = NULL, $size = NULL) {
  if (!isset($size)) {
    $size = \Drupal::config('text.settings')->get('default_summary_length');
  }

  // Find where the delimiter is in the body
  $delimiter = strpos($text, '<!--break-->');

  // If the size is zero, and there is no delimiter, the entire body is the summary.
  if ($size == 0 && $delimiter === FALSE) {
    return $text;
  }

  // If a valid delimiter has been specified, use it to chop off the summary.
  if ($delimiter !== FALSE) {
    return substr($text, 0, $delimiter);
  }

  // Retrieve the filters of the specified text format, if any.
  if (isset($format)) {
    $filters = FilterFormat::load($format)->filters();
    // If the specified format does not exist, return nothing. $text is already
    // filtered text, but the remainder of this function will not be able to
    // ensure a sane and secure summary.
    if (!$filters) {
      return '';
    }
  }

  // If we have a short body, the entire body is the summary.
  if (Unicode::strlen($text) <= $size) {
    return $text;
  }

  // If the delimiter has not been specified, try to split at paragraph or
  // sentence boundaries.

  // The summary may not be longer than maximum length specified. Initial slice.
  $summary = Unicode::truncate($text, $size);

  // Store the actual length of the UTF8 string -- which might not be the same
  // as $size.
  $max_rpos = strlen($summary);

  // How much to cut off the end of the summary so that it doesn't end in the
  // middle of a paragraph, sentence, or word.
  // Initialize it to maximum in order to find the minimum.
  $min_rpos = $max_rpos;

  // Store the reverse of the summary. We use strpos on the reversed needle and
  // haystack for speed and convenience.
  $reversed = strrev($summary);

  // Build an array of arrays of break points grouped by preference.
  $break_points = [];

  // A paragraph near the end of sliced summary is most preferable.
  $break_points[] = ['</p>' => 0];

  // If no complete paragraph then treat line breaks as paragraphs.
  $line_breaks = ['<br />' => 6, '<br>' => 4];
  // Newline only indicates a line break if line break converter
  // filter is present.
  if (isset($format) && $filters->has('filter_autop') && $filters->get('filter_autop')->status) {
    $line_breaks["\n"] = 1;
  }
  $break_points[] = $line_breaks;

  // If the first paragraph is too long, split at the end of a sentence.
  $break_points[] = ['. ' => 1, '! ' => 1, '? ' => 1, '。' => 0, '؟ ' => 1];

  // Iterate over the groups of break points until a break point is found.
  foreach ($break_points as $points) {
    // Look for each break point, starting at the end of the summary.
    foreach ($points as $point => $offset) {
      // The summary is already reversed, but the break point isn't.
      $rpos = strpos($reversed, strrev($point));
      if ($rpos !== FALSE) {
        $min_rpos = min($rpos + $offset, $min_rpos);
      }
    }

    // If a break point was found in this group, slice and stop searching.
    if ($min_rpos !== $max_rpos) {
      // Don't slice with length 0. Length must be <0 to slice from RHS.

      $summary = ($min_rpos === 0) ? $summary : substr($summary, 0, 0 - $min_rpos);
      break;
    }
  }

  // Add collapsible text to summary

  $end_paragraph = FALSE;
  $text_length = strlen($text);
  $p_closing_tag = '</p>';
  $p_closing_tag_length =  strlen($p_closing_tag);

  if (strlen($summary) != $text_length) {
    if (substr($summary, -$p_closing_tag_length) == $p_closing_tag) {

      $summary = substr($summary, 0, $text_length -$p_closing_tag_length);
      $end_paragraph = TRUE;
    }

    $summary .= ' <div class="collapse hook inline-collapse">' . substr($text, strlen($summary)) . '</div>';
    $summary .= '<a class="hook collapse inline-collapse in" data-toggle="collapse" data-target=".hook">' . t('More +'). '</a></p>';

    if ($end_paragraph) {
      $summary .= $p_closing_tag;
    }
  }


  // If the htmlcorrector filter is present, apply it to the generated summary.
  if (isset($format) && $filters->has('filter_htmlcorrector') && $filters->get('filter_htmlcorrector')->status) {
    $summary = Html::normalize($summary);
  }


  return $summary;
}

/**
 * Template preprocess function for Lorem ipsum.
 *
 * @param array $variables
 *   An associative array containing:
 *   - source_text
 */
function template_preprocess_community_selection(&$variables) {
  $variables['communities'] = Community::communityTree();
}

function template_preprocess_static_page(&$variables) {
    $language = \Drupal::languageManager()->getCurrentLanguage()->getId();
    $variables['filename'] = drupal_get_path('module', 'cogecotv_base') . "/templates/static_pages/" . $variables['page_name'] . "_" . $language . ".html.twig";
}

function cogecotv_preprocess_region(&$variables) {
  $language = \Drupal::languageManager()->getCurrentLanguage();
  // We get the path by alias because it is a created content
  // and node id is unpredictable
  $variables['url_help'] = Url::fromUri('internal:/help', ['language' => $language]);
}

function cogecotv_preprocess_page_title(&$variables) {
  $navigation = \Drupal::service('cogecotv_base.navigation');
  $session = \Drupal::service('cogecotv_base.session');
  $community_name = $session->getCurrentCommunity()->field_machine_name->getString();
  $page = \Drupal::routeMatch()->getParameter('page');
  $get_subtitle = $navigation->getSubTitlePage($community_name, $page);
  $subtitle = !empty($get_subtitle) ? $get_subtitle : '';
  $variables['sub_title'] = t($subtitle);
}